# -*- coding: utf-8 -*-
"""
Created on Mon Oct 12 09:18:57 2020

@author: wangjingxian
"""

#21. 合并两个有序链表

'''
将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的

示例：
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
'''

'''
方法以：递归调用
函数在运行时调用自己，这个函数就叫递归函数，调用的过程叫做递归。

比如定义函数 
f(x)=x+f(x−1)


这时程序会无休止地运行下去，直到崩溃。
如果我们加一个判断语句 x > 0：

这次计算 f(2)=2+f(1)=2+1+f(0)=2+1+0=3。我们从中总结两个规律：

递归函数必须要有终止条件，否则会出错；
递归函数先不断调用自身，直到遇到终止条件后进行回溯，最终返回答案。

递归解法：
根据以上规律考虑本题目：

终止条件：当两个链表都为空时，表示我们对链表已合并完成。
如何递归：我们判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。（调用递归）


我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：
list1[0]+merge(list1[1:],list2)     & list1[0] < list2[0] \\
list2[0] + merge(list1, list2[1:]) & otherwise
也就是说，两个链表头部值较小的一个节点与剩下元素的 merge操作结果合并。
'''

class Solution:
    def mergeTwoLists(self,l1,l2):
        if not l1:return l2   #终止条件，直到两个链表都为空
        if not l2:return l1
        if l1.val<=l2.val:  #递归调用
            l1.next=self.mergeTwoLists(l1.next,l2)
            return l1
        else:
            l2.next=self.mergeTwoLists(l1,l2.next)
            return l2
        
        
'''
时间复杂度：O(m+n)。
m，n为 l1和 l2的元素个数。递归函数每次去掉一个元素，直到两个链表都为空，因此需要调用 R=O(m+n)次。
而在递归函数中我们只进行了 next 指针的赋值操作，复杂度为 O(1)，故递归的总时间复杂度为 O(T)=R∗O(1)=O(m+n)
空间复杂度：O(m+n)。**
对于递归调用 self.mergeTwoLists()，当它遇到终止条件准备回溯时，已经递归调用了 m+n次，使用了 m+n个栈帧，
故最后的空间复杂度为 O(m+n)。leetcode时间复杂度和空间复杂度更低
'''
     


   
'''
方法二：迭代
思路
我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，
将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。
算法：
首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，
我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：
如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。
否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。
在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，
它包含的所有元素都比前面已经合并链表中的所有元素都要大。
这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

'''

class Solution:
    def mergeTwoLists(self,l1,l2):
        prehead=ListNode(-1)
        
        prev=prehead
        
        while l1 and l2:
            if l1.val<=l2.val:
                prev.next=l1
                l1=l1.next
                
            else:
                prev.next=l2
                l2=l2.next
                
            prev=prev.next
            
        prev.next=l1 if l1 is not None else l2
        
        return prehead.next
    
'''    
时间复杂度：O(n+m)，其中 n和 m分别为两个链表的长度。
因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中，
 因此 while 循环的次数不会超过两个链表的长度之和。
 所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。

空间复杂度：O(1)。我们只需要常数的空间存放若干变量。
'''
